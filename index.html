<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Tela – Simil Prezi (pulita) con curve, delete, immagini e video</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:rgba(255,255,255,.92);
      --txt:#111;
      --muted:#444;
      --border:rgba(0,0,0,.18);
      --accent:#1f6fff;
      --shadow:0 14px 38px rgba(0,0,0,.12);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--txt); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #viewport{ position:fixed; inset:0; overflow:hidden; touch-action:none; background:var(--bg); }

    #hud{
      position:fixed; inset:12px auto auto 12px; z-index:50;
      background:var(--panel); backdrop-filter: blur(10px);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      box-shadow: var(--shadow);
    }
    #hud button{
      background:#fff; color:var(--txt);
      border:1px solid var(--border);
      padding:8px 10px; border-radius:12px; cursor:pointer;
    }
    #hud button:hover{ border-color:rgba(0,0,0,.32); }
    #hud button.active{
      border-color: rgba(31,111,255,.75);
      box-shadow: 0 0 0 3px rgba(31,111,255,.10) inset;
    }
    #hud .info{ font-size:12px; color:var(--muted); white-space:nowrap; }

    #world{
      position:absolute; left:50%; top:50%;
      transform-origin:0 0;
    }

    /* SVG link layer */
    #linksSvg{
      position:absolute; left:0; top:0;
      overflow:visible;
      pointer-events:auto;
    }

    .node{
      position:absolute;
      min-width:210px; max-width:460px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 14px;
      box-shadow: var(--shadow);
      cursor:grab;
      user-select:none;
    }
    .node:active{ cursor:grabbing; }
    .node.selected{
      border-color: rgba(31,111,255,.8);
      box-shadow: 0 0 0 3px rgba(31,111,255,.12), var(--shadow);
    }
    .node h3{ margin:0 0 6px 0; font-size:14px; letter-spacing:.2px; }
    .node p{ margin:0; font-size:13px; color:var(--muted); line-height:1.3; }

    .node .tag{
      display:inline-block; margin-top:10px;
      font-size:11px; color:#0b2d7a;
      background:rgba(31,111,255,.10);
      border:1px solid rgba(31,111,255,.22);
      padding:3px 8px; border-radius:999px;
    }

    /* image/video nodes */
    .node.media{ padding:10px; min-width:240px; }
    .node.media img.thumb{
      width:100%;
      display:block;
      border-radius:12px;
      border:1px solid rgba(0,0,0,.12);
      background:#f2f2f2;
    }
    .node.media .caption{
      margin:8px 4px 0 4px;
      font-size:12px; color:var(--muted);
    }

    /* SVG styles */
    .linkPath{
      fill:none;
      stroke:rgba(0,0,0,.70);
      stroke-width:3;
      stroke-linecap:round;
      stroke-linejoin:round;
      pointer-events:stroke;
    }
    .linkPath.selected{
      stroke: rgba(31,111,255,.95);
      stroke-width:4;
    }
    .linkHit{
      fill:none;
      stroke:rgba(0,0,0,0);
      stroke-width:16;
      pointer-events:stroke;
    }

    /* Handle ON the curve (point on arc) */
    .handle{
      cursor:grab;
      fill: rgba(31,111,255,.95);
      stroke: rgba(255,255,255,.9);
      stroke-width:1.5;
    }
    .handle:active{ cursor:grabbing; }
    .handle.selected{
      r: 10;
      filter: drop-shadow(0 6px 10px rgba(31,111,255,.25));
    }

    /* Modal */
    #modal{
      position:fixed; inset:0; display:none; place-items:center; z-index:80;
      background:rgba(0,0,0,.55);
    }
    #modal .card{
      width:min(920px, calc(100% - 28px));
      background:#fff;
      border:1px solid rgba(0,0,0,.18);
      border-radius:18px;
      padding:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.35);
    }
    #modal .card header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin-bottom:10px;
    }
    #modal .card header strong{ font-size:14px; }
    #modal .close{
      border:1px solid rgba(0,0,0,.18);
      background:#fff; color:#111;
      border-radius:12px; padding:6px 10px; cursor:pointer;
    }
    #modal .body{ color:#111; font-size:14px; line-height:1.45; }
    #modal img.big{
      width:100%; height:auto;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.12);
      background:#f2f2f2;
      display:block;
    }
    #modal .videoWrap{
      width:100%;
      aspect-ratio: 16/9;
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,.12);
      background:#000;
    }
    #modal iframe, #modal video{
      width:100%;
      height:100%;
      border:0;
      display:block;
      background:#000;
    }

    #fileInput{ display:none; }
  </style>
</head>
<body>

  <div id="hud">
    <button id="btnHome" title="Ritorna a zoom 1 e centro">Home</button>
    <button id="btnConnect" title="Crea connettori: clicca due nodi">Connetti</button>

    <button id="btnAddText" title="Aggiungi nodo di testo">+ Testo</button>
    <button id="btnAddImgUrl" title="Immagine da URL esterno">+ Immagine (URL)</button>
    <button id="btnAddImgUpload" title="Carica immagine locale">+ Immagine (Upload)</button>
    <button id="btnAddVideo" title="Immagine cliccabile che apre un video">+ Video</button>

    <button id="btnDeleteSelected" title="Cancella nodo o connettore selezionato">Cancella selezionato</button>
    <button id="btnClearAll" title="Cancella tutto">Cancella tutto</button>

    <div class="info" id="info">Tavola bianca. Aggiungi tu i contenuti.</div>
  </div>

  <input id="fileInput" type="file" accept="image/*" />

  <div id="viewport">
    <div id="world">
      <svg id="linksSvg"></svg>
      <!-- nodes -->
    </div>
  </div>

  <div id="modal">
    <div class="card">
      <header>
        <strong id="mTitle">Contenuto</strong>
        <button class="close" id="mClose">Chiudi</button>
      </header>
      <div class="body" id="mBody"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- Elements ----------
  const viewport = document.getElementById('viewport');
  const world = document.getElementById('world');
  const linksSvg = document.getElementById('linksSvg');
  const info = document.getElementById('info');
  const fileInput = document.getElementById('fileInput');

  const modal = document.getElementById('modal');
  const mTitle = document.getElementById('mTitle');
  const mBody  = document.getElementById('mBody');
  const mClose = document.getElementById('mClose');

  // ---------- State ----------
  // Camera
  let cam = { x: 0, y: 0, s: 1 };
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  // Data (START CLEAN)
  const nodes = []; // {id,type,x,y,w,h,title,subtitle,body,src,caption,videoUrl}
  const links = []; // {id, from, to, bend:{x,y}}  <-- bend point is ON the curve (midpoint)

  // Modes
  let mode = 'normal'; // 'normal' | 'connect'
  let pendingFrom = null;

  // Selection
  let selected = null; // {type:'node'|'link', id:string}

  // ---------- Camera helpers ----------
  function applyCam() {
    world.style.transform = `translate(${cam.x}px, ${cam.y}px) scale(${cam.s})`;
    const msg = mode === 'connect'
      ? 'MODALITÀ CONNETTI: clicca 2 nodi (poi trascina la maniglia sull’arco).'
      : 'Pan: trascina sfondo · Zoom: rotella/pinch · Click: seleziona · Doppio click nodo: focus';
    info.textContent = `zoom:${cam.s.toFixed(2)} · ${msg}`;
  }

  function screenToWorld(px, py) {
    const rect = viewport.getBoundingClientRect();
    const sx = px - rect.left;
    const sy = py - rect.top;
    return { x: (sx - cam.x) / cam.s, y: (sy - cam.y) / cam.s };
  }

  function zoomAt(px, py, factor) {
    const before = screenToWorld(px, py);
    cam.s = clamp(cam.s * factor, 0.2, 4);
    const rect = viewport.getBoundingClientRect();
    const sx = px - rect.left;
    const sy = py - rect.top;
    cam.x = sx - before.x * cam.s;
    cam.y = sy - before.y * cam.s;
    applyCam();
  }

  // ---------- Modal ----------
  function closeModal(){
    modal.style.display = 'none';
    // stop video/iframe by clearing content
    mBody.innerHTML = '';
  }
  mClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=> { if (e.target === modal) closeModal(); });

  // ---------- Selection ----------
  function setSelected(obj){
    selected = obj; // or null
    render(); // refresh highlight
  }
  function clearSelection(){ setSelected(null); }

  // ---------- Node geometry ----------
  function nodeDims(n){
    return { w: n.w || 280, h: n.h || (n.type === 'media' ? 220 : 130) };
  }
  function nodeCenter(n){
    const {w,h} = nodeDims(n);
    return { x: n.x + w/2, y: n.y + h/2 };
  }

  // ---------- Bezier math ----------
  // We store bend point B = point on curve at t=0.5 (midpoint on arc).
  // For quadratic bezier: P0 = start, P2 = end, P1 = control.
  // Condition: Curve midpoint M at t=0.5 equals bend point B.
  // B = 0.25 P0 + 0.5 P1 + 0.25 P2  =>  P1 = 2B - 0.5(P0+P2)
  function controlFromBend(P0, P2, B){
    return {
      x: 2*B.x - 0.5*(P0.x + P2.x),
      y: 2*B.y - 0.5*(P0.y + P2.y)
    };
  }
  function midpointOnQuad(P0, P1, P2){
    return {
      x: 0.25*P0.x + 0.5*P1.x + 0.25*P2.x,
      y: 0.25*P0.y + 0.5*P1.y + 0.25*P2.y
    };
  }

  // ---------- Render ----------
  function render(){
    renderLinks();
    renderNodes();
  }

  function renderNodes(){
    [...world.querySelectorAll('.node')].forEach(x => x.remove());

    nodes.forEach(n => {
      const {w} = nodeDims(n);
      const el = document.createElement('div');
      el.className = 'node';
      el.dataset.id = n.id;
      el.style.left = `${n.x}px`;
      el.style.top  = `${n.y}px`;
      el.style.width = `${w}px`;

      if (selected && selected.type === 'node' && selected.id === n.id) {
        el.classList.add('selected');
      }

      if (n.type === 'text') {
        el.innerHTML = `
          <h3>${escapeHtml(n.title || 'Titolo')}</h3>
          <p>${escapeHtml(n.subtitle || '')}</p>
          <span class="tag">${mode==='connect' ? 'Seleziona' : 'Apri / Seleziona'}</span>
        `;
      } else {
        // media: image or video-with-thumb
        el.classList.add('media');
        el.innerHTML = `
          <img class="thumb" src="${escapeAttr(n.src || '')}" alt="">
          <div class="caption">${escapeHtml(n.caption || '')}</div>
          <span class="tag">${n.videoUrl ? 'Video' : 'Immagine'} · ${mode==='connect' ? 'Seleziona' : 'Apri / Seleziona'}</span>
        `;
        // img error fallback
        const img = el.querySelector('img.thumb');
        img.addEventListener('error', () => {
          img.replaceWith(Object.assign(document.createElement('div'), {
            style: 'padding:18px; border-radius:12px; border:1px dashed rgba(0,0,0,.25); color:var(--muted); font-size:12px;',
            textContent: 'Immagine non caricabile. URL errato o hotlink bloccato dal sito.'
          }));
        });
      }

      attachNodeInteractions(el, n);
      world.appendChild(el);
    });
  }

  function attachNodeInteractions(el, n){
    // Drag node
    let dragging = false;
    let start = {x:0,y:0,nx:0,ny:0};

    el.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      dragging = true;
      start = { x:e.clientX, y:e.clientY, nx:n.x, ny:n.y };
      // select on down (feels immediate)
      setSelected({type:'node', id:n.id});
    });

    el.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      const dx = (e.clientX - start.x) / cam.s;
      const dy = (e.clientY - start.y) / cam.s;
      n.x = start.nx + dx;
      n.y = start.ny + dy;
      // update view without rebuilding nodes (cheaper):
      el.style.left = `${n.x}px`;
      el.style.top  = `${n.y}px`;
      renderLinks(); // keep links attached
    });

    el.addEventListener('pointerup', ()=> dragging = false);

    // Click behavior:
    el.addEventListener('click', (e)=> {
      e.stopPropagation();
      if (mode === 'connect') {
        pickNodeForLink(n.id);
        return;
      }
      // normal: open content (but still stays selected)
      openNode(n);
    });

    // Double click: focus
    el.addEventListener('dblclick', (e)=> {
      e.stopPropagation();
      focusNode(n);
    });
  }

  function renderLinks(){
    linksSvg.innerHTML = '';
    linksSvg.setAttribute('width','1');
    linksSvg.setAttribute('height','1');

    links.forEach(link => {
      const a = nodes.find(n=>n.id===link.from);
      const b = nodes.find(n=>n.id===link.to);
      if (!a || !b) return;

      const P0 = nodeCenter(a);
      const P2 = nodeCenter(b);

      // bend point is ON the curve midpoint
      const B = link.bend || { x:(P0.x+P2.x)/2, y:(P0.y+P2.y)/2 };
      const P1 = controlFromBend(P0, P2, B);

      const d = `M ${P0.x} ${P0.y} Q ${P1.x} ${P1.y} ${P2.x} ${P2.y}`;

      // visible path
      const path = svgEl('path');
      path.setAttribute('d', d);
      path.setAttribute('class', 'linkPath');
      if (selected && selected.type==='link' && selected.id===link.id) {
        path.classList.add('selected');
      }
      linksSvg.appendChild(path);

      // hit area path for easy selection
      const hit = svgEl('path');
      hit.setAttribute('d', d);
      hit.setAttribute('class', 'linkHit');
      linksSvg.appendChild(hit);

      // handle point: exactly B (on arc)
      const handle = svgEl('circle');
      handle.setAttribute('cx', B.x);
      handle.setAttribute('cy', B.y);
      handle.setAttribute('r', 8);
      handle.setAttribute('class', 'handle');
      if (selected && selected.type==='link' && selected.id===link.id) {
        handle.classList.add('selected');
      }
      linksSvg.appendChild(handle);

      // select link on click (either hit or path)
      const selectLink = (e) => {
        e.stopPropagation();
        setSelected({type:'link', id:link.id});
      };
      hit.addEventListener('click', selectLink);
      path.addEventListener('click', selectLink);
      handle.addEventListener('click', selectLink);

      // drag handle (updates bend point B directly, stays on arc by definition)
      let dragging = false;
      handle.addEventListener('pointerdown', (e)=> {
        e.stopPropagation();
        e.preventDefault();
        handle.setPointerCapture(e.pointerId);
        dragging = true;
        setSelected({type:'link', id:link.id});
      });
      handle.addEventListener('pointermove', (e)=> {
        if (!dragging) return;
        const p = screenToWorld(e.clientX, e.clientY);
        link.bend = { x:p.x, y:p.y };
        // re-render links only
        renderLinks();
      });
      handle.addEventListener('pointerup', ()=> dragging = false);
    });
  }

  function svgEl(name){
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // ---------- Open node ----------
  function openNode(n){
    mTitle.textContent = n.title || 'Contenuto';

    if (n.type === 'text') {
      const body = (n.body || '').trim();
      const sub  = (n.subtitle || '').trim();
      mBody.innerHTML = `
        ${sub ? `<div style="color:#444; margin-bottom:10px;"><strong>${escapeHtml(sub)}</strong></div>` : ''}
        <div style="white-space:pre-wrap; color:#111;">${escapeHtml(body || '')}</div>
      `;
      modal.style.display = 'grid';
      return;
    }

    // media node
    if (n.videoUrl) {
      const embed = videoEmbedHtml(n.videoUrl);
      mBody.innerHTML = `
        <div class="videoWrap">${embed}</div>
        ${n.caption ? `<div style="margin-top:10px; color:#444; font-size:13px;">${escapeHtml(n.caption)}</div>` : ''}
      `;
      modal.style.display = 'grid';
      return;
    }

    // image
    mBody.innerHTML = `
      <img class="big" src="${escapeAttr(n.src||'')}" alt="">
      ${n.caption ? `<div style="margin-top:10px; color:#444; font-size:13px;">${escapeHtml(n.caption)}</div>` : ''}
    `;
    modal.style.display = 'grid';
  }

  function videoEmbedHtml(url){
    const u = String(url).trim();

    // YouTube: watch?v=... or youtu.be/...
    const yt = parseYouTube(u);
    if (yt) {
      const src = `https://www.youtube.com/embed/${yt}?autoplay=1`;
      return `<iframe src="${escapeAttr(src)}" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>`;
    }

    // Direct video file
    if (/\.(mp4|webm|ogg)(\?.*)?$/i.test(u)) {
      return `<video src="${escapeAttr(u)}" controls playsinline></video>`;
    }

    // Generic iframe (works only if the site allows embedding)
    return `<iframe src="${escapeAttr(u)}" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>`;
  }

  function parseYouTube(url){
    try{
      const u = new URL(url);
      if (u.hostname.includes('youtu.be')) {
        const id = u.pathname.replace('/','').trim();
        return id || null;
      }
      if (u.hostname.includes('youtube.com')) {
        const v = u.searchParams.get('v');
        if (v) return v;
        // already /embed/ID
        const m = u.pathname.match(/\/embed\/([a-zA-Z0-9_-]+)/);
        if (m) return m[1];
      }
    }catch(_){}
    return null;
  }

  // ---------- Focus ----------
  function focusNode(n){
    const targetZoom = 1.7;
    cam.s = targetZoom;
    const rect = viewport.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;
    const c = nodeCenter(n);
    cam.x = cx - c.x * cam.s;
    cam.y = cy - c.y * cam.s;
    applyCam();
  }
  function home(){ cam = {x:0,y:0,s:1}; applyCam(); }

  // ---------- Pan / Zoom ----------
  let panning = false;
  let panStart = {x:0,y:0,cx:0,cy:0};

  viewport.addEventListener('pointerdown', (e)=> {
    // click on empty background -> clear selection
    if (e.target === viewport) clearSelection();
    panning = true;
    viewport.setPointerCapture(e.pointerId);
    panStart = { x:e.clientX, y:e.clientY, cx:cam.x, cy:cam.y };
  });
  viewport.addEventListener('pointermove', (e)=> {
    if (!panning) return;
    cam.x = panStart.cx + (e.clientX - panStart.x);
    cam.y = panStart.cy + (e.clientY - panStart.y);
    applyCam();
  });
  viewport.addEventListener('pointerup', ()=> panning = false);

  viewport.addEventListener('wheel', (e)=> {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.08 : 0.92;
    zoomAt(e.clientX, e.clientY, factor);
  }, { passive:false });

  // Minimal pinch zoom
  const lastPointers = new Map();
  let pinch = { active:false, id1:null, id2:null, d0:0, mid:{x:0,y:0} };

  viewport.addEventListener('pointerdown', (e)=> {
    lastPointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
    if (!pinch.id1) pinch.id1 = e.pointerId;
    else if (!pinch.id2) {
      pinch.id2 = e.pointerId;
      pinch.active = true;
      const p1 = lastPointers.get(pinch.id1);
      const p2 = lastPointers.get(pinch.id2);
      pinch.d0 = dist(p1,p2);
      pinch.mid = { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 };
    }
  });
  viewport.addEventListener('pointermove', (e)=> {
    lastPointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
    if (!pinch.active) return;
    if (!lastPointers.has(pinch.id1) || !lastPointers.has(pinch.id2)) return;
    const p1 = lastPointers.get(pinch.id1);
    const p2 = lastPointers.get(pinch.id2);
    const d = dist(p1,p2);
    const factor = clamp(d / pinch.d0, 0.85, 1.15);
    zoomAt(pinch.mid.x, pinch.mid.y, factor);
    pinch.d0 = d;
  });
  viewport.addEventListener('pointerup', (e)=> {
    lastPointers.delete(e.pointerId);
    if (e.pointerId === pinch.id1) pinch.id1 = null;
    if (e.pointerId === pinch.id2) pinch.id2 = null;
    if (!pinch.id1 || !pinch.id2) pinch.active = false;
  });
  function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }

  // ---------- Connect mode ----------
  function setMode(m){
    mode = m;
    pendingFrom = null;
    document.getElementById('btnConnect').classList.toggle('active', mode==='connect');
    render();
    applyCam();
  }

  function pickNodeForLink(nodeId){
    if (!pendingFrom) {
      pendingFrom = nodeId;
      info.textContent = `MODALITÀ CONNETTI: scelto ${nodeId}. Ora clicca il secondo nodo.`;
      return;
    }
    if (pendingFrom === nodeId) return;

    const a = nodes.find(n=>n.id===pendingFrom);
    const b = nodes.find(n=>n.id===nodeId);
    if (!a || !b) { pendingFrom = null; return; }

    const P0 = nodeCenter(a);
    const P2 = nodeCenter(b);
    const mid = { x:(P0.x+P2.x)/2, y:(P0.y+P2.y)/2 };

    // Initial bend point ON arc: start with a mild upward offset
    const bend = { x: mid.x, y: mid.y - 90 };

    const link = {
      id: 'l' + Math.random().toString(16).slice(2),
      from: pendingFrom,
      to: nodeId,
      bend
    };
    links.push(link);
    pendingFrom = null;

    setSelected({type:'link', id:link.id});
    renderLinks();
    info.textContent = `Connettore creato. Trascina la maniglia sull’arco per piegarlo.`;
  }

  // ---------- Add nodes ----------
  function addTextNode(){
    const title = prompt('Titolo del nodo:','') ?? '';
    if (title === null) return;
    const subtitle = prompt('Sottotitolo (facoltativo):','') ?? '';
    if (subtitle === null) return;
    const body = prompt('Testo (puoi incollare anche lungo):','') ?? '';
    if (body === null) return;

    const n = {
      id: 'n' + Math.random().toString(16).slice(2),
      type: 'text',
      x: -140, y: -80,
      w: 300, h: 130,
      title: title.trim() || 'Nodo testo',
      subtitle: subtitle.trim(),
      body: body
    };
    nodes.push(n);
    setSelected({type:'node', id:n.id});
    render();
  }

  function addImageUrlNode(){
    const url = prompt("URL immagine (https://...):","");
    if (!url) return;
    const caption = prompt("Didascalia (facoltativa):","") || '';
    const title = prompt("Titolo (facoltativo):","Immagine") || 'Immagine';

    const n = {
      id: 'n' + Math.random().toString(16).slice(2),
      type: 'media',
      x: -160, y: -100,
      w: 360, h: 240,
      title: title.trim(),
      caption: caption.trim(),
      src: url.trim(),
      videoUrl: null
    };
    nodes.push(n);
    setSelected({type:'node', id:n.id});
    render();
  }

  function addImageUploadNode(file){
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = reader.result;
      const caption = prompt("Didascalia (facoltativa):","") || '';
      const title = prompt("Titolo (facoltativo):", file.name || "Immagine") || (file.name || "Immagine");

      const n = {
        id: 'n' + Math.random().toString(16).slice(2),
        type: 'media',
        x: -160, y: -100,
        w: 360, h: 240,
        title: title.trim(),
        caption: caption.trim(),
        src: dataUrl,
        videoUrl: null
      };
      nodes.push(n);
      setSelected({type:'node', id:n.id});
      render();
    };
    reader.readAsDataURL(file);
  }

  function addVideoNode(){
    const thumb = prompt("Immagine/thumbnail (URL immagine) — es. copertina:","");
    if (!thumb) return;
    const videoUrl = prompt("URL video (YouTube link o file .mp4/.webm):","");
    if (!videoUrl) return;

    const caption = prompt("Didascalia (facoltativa):","") || '';
    const title = prompt("Titolo (facoltativo):","Video") || 'Video';

    const n = {
      id: 'n' + Math.random().toString(16).slice(2),
      type: 'media',
      x: -160, y: -100,
      w: 360, h: 240,
      title: title.trim(),
      caption: caption.trim(),
      src: thumb.trim(),
      videoUrl: videoUrl.trim()
    };
    nodes.push(n);
    setSelected({type:'node', id:n.id});
    render();
  }

  // ---------- Delete ----------
  function deleteSelected(){
    if (!selected) return;

    if (selected.type === 'node') {
      const idx = nodes.findIndex(n=>n.id===selected.id);
      if (idx === -1) return;

      const nodeId = nodes[idx].id;
      nodes.splice(idx,1);

      // remove links connected to that node
      for (let i = links.length-1; i>=0; i--){
        if (links[i].from === nodeId || links[i].to === nodeId) links.splice(i,1);
      }

      clearSelection();
      render();
      return;
    }

    if (selected.type === 'link') {
      const idx = links.findIndex(l=>l.id===selected.id);
      if (idx === -1) return;
      links.splice(idx,1);
      clearSelection();
      renderLinks();
      return;
    }
  }

  function clearAll(){
    if (!confirm('Cancello TUTTO (nodi e connettori). Confermi?')) return;
    nodes.length = 0;
    links.length = 0;
    pendingFrom = null;
    clearSelection();
    render();
    info.textContent = 'Tavola bianca. Aggiungi tu i contenuti.';
  }

  // ---------- HUD wiring ----------
  document.getElementById('btnHome').onclick = home;

  document.getElementById('btnConnect').onclick = () => {
    setMode(mode === 'connect' ? 'normal' : 'connect');
  };

  document.getElementById('btnAddText').onclick = addTextNode;
  document.getElementById('btnAddImgUrl').onclick = addImageUrlNode;
  document.getElementById('btnAddImgUpload').onclick = () => fileInput.click();
  document.getElementById('btnAddVideo').onclick = addVideoNode;

  document.getElementById('btnDeleteSelected').onclick = deleteSelected;
  document.getElementById('btnClearAll').onclick = clearAll;

  fileInput.addEventListener('change', (e)=> {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    addImageUploadNode(file);
    fileInput.value = '';
  });

  // ---------- Utilities ----------
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[s]));
  }
  function escapeAttr(str){
    return String(str).replace(/"/g, '&quot;');
  }

  // ---------- Init ----------
  render();     // empty, clean
  home();
  info.textContent = 'Tavola bianca. Aggiungi tu i contenuti.';
})();
</script>
</body>
</html>
